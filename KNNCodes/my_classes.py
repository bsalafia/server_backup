# -*- coding: utf-8 -*-
"""my_classes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m68V4RcnWhqWUUZOByvuJfNB2UzGI-Cs
"""

import numpy as np
import keras
class DataGenerator(keras.utils.Sequence):
  def __init__(self, list_examples, batch_size=256, dim=(1000, 20),
                n_classes=2, shuffle=True):
    # Constructor of the data generator.
    self.dim = dim
    self.batch_size = batch_size
    self.list_examples = list_examples
    self.n_classes = n_classes
    self.shuffle = shuffle
    self.on_epoch_end()

  def __len__(self):
    # Denotes the number of batches per epoch
    return int(np.floor(len(self.list_examples) / self.batch_size))

  def __getitem__(self, index):
    # Generate one batch of data
    indexes = self.indexes[index*self.batch_size:(index+1)*self.batch_size]

    # Find list of IDs
    list_IDs_temp = [self.list_examples[k] for k in indexes]

    # Generate data
    X, y = self.__data_generation(list_IDs_temp)

    return X, y

  def on_epoch_end(self):
    # This function is called at the end of each epoch.
    self.indexes = np.arange(len(self.list_examples))
    if self.shuffle == True:
      np.random.shuffle(self.indexes)

  def __data_generation(self, list_IDs_temp):
    # Load individual numpy arrays and aggregate them to a batch.
    
    X = np.empty([self.batch_size, self.dim[0], self.dim[1]])
    
    # y is a one-hot encoded vector.
    y = np.empty([self.batch_size, 1], dtype=int)

    # Generate data.
    for i, ID in enumerate(list_IDs_temp):

        # Load sample
        X[i,:, :] = loadmat(ID[0])['data']
        # Load labels       
        y[i, :] =ID[1]

    return X, y