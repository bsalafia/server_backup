# -*- coding: utf-8 -*-
"""DifferentCorrelations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l-bLR_1S0YJadgXYek-nG56zBFfMq7RL
"""

# pip install minepy

# pip install tslearn

import os
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"]="4"
# from pycit.estimators import ksg_mi,bi_ksg_cmi,mixed_mi,mixed_cmi,bi_ksg_mi
# from pycit.preprocessing import low_amplitude_noise
import sys
import scipy
import h5py
import glob, os
from scipy.io import loadmat,savemat
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
from sklearn import preprocessing
from keras import regularizers
from numpy import mean
from numpy import std
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
import torch
import torch.nn as nn
from tqdm.auto import tqdm, trange
from numpy.random import default_rng
import torch.nn.functional as F
from scipy.signal import hilbert, butter, filtfilt
from scipy.fftpack import fft,fftfreq,rfft,irfft,ifft
import gc
import time
# from numpy.lib.stride_tricks import sliding_window_view
from numba import jit, njit, prange
from numpy.random import randn
from numpy.random import seed
from scipy.stats import pearsonr,spearmanr
# from google.colab import drive
from scipy.spatial.distance import pdist, squareform
from minepy import MINE
# import statsmodels.api as sm
from tslearn.metrics import dtw, dtw_path
# drive.mount('/content/drive')

def PatientsName():
    Name=['chb01','chb02','chb03','chb04','chb05','chb06','chb07','chb08','chb09','chb10',
    'chb11','chb12','chb13','chb14','chb15','chb16','chb17','chb18','chb19','chb20','chb21',
    'chb22','chb23','chb24']

    return Name

def PatientsEDFFile(dirname):

    os.chdir(dirname)
    a=[]
    X=[]
    Y=[]
    k=0
    for file in glob.glob("*.mat"):

        a.append(file)
        # print(a)

    return a

def LoadData(dirname,indx):

    os.chdir(dirname)
    a=[]
    X=[]
    Y=[]
    k=0
    for file in glob.glob("*.mat"):

        a.append(file)
    print(a)
    Name=[a[x] for x in indx]
    # for i in range(len(Name)):

    matFile1 = h5py.File(os.path.join(dirname, Name[0]),'r')
    xx=matFile1.get('input')
    yy=matFile1.get('target')
    x1=np.array(xx)
    y1=np.array(yy)
    x= np.transpose(x1)
    y=np.transpose(y1)
    # step=x.shape[0]
    # X.append(x)
    # Y.append(y)
    # k=k+step

    # xx = np.concatenate(X, axis=0)
    # yy = np.concatenate(Y, axis=0)
    return x,y,Name[0]

def Label(dirname,Name,WindowSize1,WindowSize2):

  DenoisedSig,Fs,Siezure_start,Siezure_end,Sig_start,Sig_end = LoadData(dirname,Name)

  n_channels= DenoisedSig.shape[0]

  # X=np.zeros((np.int64(Sig_end)-np.int64(Sig_start)-WindowSize+1,n_channels,WindowSize*Fs))

  # Ylabel=np.zeros((np.int64(Sig_end)-np.int64(Sig_start)-WindowSize+1,1))

  n1=1
  n2=1+WindowSize1
  s=Siezure_start-Sig_start+1
  e=Siezure_end-Sig_start+1
  t1 = 0
  t2 = WindowSize1*Fs
  X=[]
  Ylabel=[]
  Ylabel_4sec=[]
  Sup=DenoisedSig.shape[1]
  k=0

  while t2 <= Sup:


    X.append(DenoisedSig[:,t1:min(t2,Sup)])

    if  (n2<=s or n1>=e):
      Ylabel.append(0)

    elif (n1<s and n2<e):

      Ylabel.append(min(n2-s,e-s,WindowSize1)/WindowSize1)

    elif (n1>=s and n2<=e):
      Ylabel.append(1)

    elif n2>=e:
      Ylabel.append(min(e-n1,e-s)/WindowSize1)

    n11=n2-WindowSize2

    if  (n2<=s or n11>=e):

      Ylabel_4sec.append(0)

    elif (n11<s and n2<e):

      Ylabel_4sec.append(min(n2-s,e-s,WindowSize2)/WindowSize2)

    elif (n11>=s and n2<=e):

      Ylabel_4sec.append(1)

    elif n2>=e:

      Ylabel_4sec.append(min(e-n11,e-s)/WindowSize2)

    if t2+Fs > Sup:
      X=np.array(X)
      X_4sec=X[:,:,-1024::]

    t2 = t2 + Fs
    t1 = t1 + Fs
    n2=n2+1
    n1=n1+1
    k  = k + 1

  X=np.array(X)
  Ylabel=np.array(Ylabel)
  Ylabel_4sec=np.array(Ylabel_4sec)
  return X,Ylabel,X_4sec,Ylabel_4sec

def phase_synchrony(a,b):

  al1 = np.angle(hilbert(a),deg=False)
  al2 = np.angle(hilbert(b),deg=False)
  phase = 1-np.sin(np.abs(al1-al2)/2)
  out=np.mean(phase)

  return out

def distcorr(X, Y):
    """ Compute the distance correlation function

    >>> a = [1,2,3,4,5]
    >>> b = np.array([1,2,9,4,4])
    >>> distcorr(a, b)
    0.762676242417
    """
    X = np.atleast_1d(X)
    Y = np.atleast_1d(Y)
    if np.prod(X.shape) == len(X):
        X = X[:, None]
    if np.prod(Y.shape) == len(Y):
        Y = Y[:, None]
    X = np.atleast_2d(X)
    Y = np.atleast_2d(Y)
    n = X.shape[0]
    if Y.shape[0] != X.shape[0]:
        raise ValueError('Number of samples must match')
    a = squareform(pdist(X))
    b = squareform(pdist(Y))
    A = a - a.mean(axis=0)[None, :] - a.mean(axis=1)[:, None] + a.mean()
    B = b - b.mean(axis=0)[None, :] - b.mean(axis=1)[:, None] + b.mean()

    dcov2_xy = (A * B).sum()/float(n * n)
    dcov2_xx = (A * A).sum()/float(n * n)
    dcov2_yy = (B * B).sum()/float(n * n)
    dcor = np.sqrt(dcov2_xy)/np.sqrt(np.sqrt(dcov2_xx) * np.sqrt(dcov2_yy))
    return dcor

def MIC(x,y):

  mine = MINE(alpha=0.6, c=15)
  mine.compute_score(x, y)

  return mine.mic()

def TLCC(x,y):
  corr=sm.tsa.stattools.ccf(x,y,unbiased=False)
  ind=list(corr).index(max(list(corr)))

  return corr[ind]

def Correlation_Calulation(x,y,Pearson,phase,distance,mic,tlcc,DWT):

  if Pearson==1:
    corr, _ = pearsonr(x,y)

  if phase==1:
    corr=phase_synchrony(x,y)

  if distance==1:
    corr=distcorr(x,y)

  if mic==1:

    corr=MIC(x,y)

  if tlcc==1:

    corr=TLCC(x,y)


  if DWT==1:

    corr=dtw(x, y)

  return corr

####################### you can change this line: for file_idx in [0]  to run for more patients, for instance: for file_idx in [0,1,2,3]. ############################
def correlation(Extention,dirname,savedir,Pearson,phase,distance,mic,tlcc,DWT):
  labels = [0, 1]

  EDFFiles=PatientsEDFFile(dirname)
  start_time = time.time()

  for file_idx in [18]:

    X_train,Y_train,Name=LoadData(dirname, [file_idx])
    print(Name)
    signal_max = np.max(X_train,axis=(0,1))


    estimated_MI = np.zeros((len(labels), X_train.shape[2], X_train.shape[2]))

    for l in labels:

      for j in range(X_train.shape[2]-1):

        for k in range(j+1, X_train.shape[2]):

          estimates=[]

          for i in range(X_train.shape[0]):

            if Y_train[i] != l:
              continue

            X = X_train[i, :, j]/signal_max[j]
            Y = X_train[i, :, k]/signal_max[k]


            corr=Correlation_Calulation(X,Y,Pearson,phase,distance,mic,tlcc,DWT)
            estimates.append(corr)

          # estimates = np.concatenate(estimates)
          estimated_MI[l,j,k] = np.mean(np.array(estimates))
          # time.sleep(0.5)
          print("-----File_idx {}, Label {}, Chan1 {},  Chan2 {}, Estimated MI {:.4f}".format(file_idx, l, j, k, estimated_MI[l,j,k]))

      Name2=EDFFiles[file_idx].split('.')
      savemat(os.path.join(savedir, Name2[0]+'_RollWindow_AllFiles_Normal'+Extention+'.mat'), {"estimated_MI": estimated_MI})
      # print("-----File_idx {}, Label {}, Chan1 {},  Chan2 {}, Estimated MI {:.4f}".format(file_idx, l, j, k, estimated_MI[l,j,k]))

      print("--- %s seconds ---" % (time.time() - start_time))



dirname='/media/datadrive/bsalafian/1DCNNDataset'
savedir='/home/baharsalafian/'

Extention='DWT'
correlation(Extention,dirname,savedir+Extention+'/',Pearson=0,phase=0,distance=0,mic=0,tlcc=0,DWT=1)







# # this is for KNN
# # dirname = '/content/drive/MyDrive/Colab Notebooks/Bahareh/1D CNNDataset'
# dir_mi_results = '/content/drive/MyDrive/Colab Notebooks/Bahareh/CorrelationCheckForDrFarsad/Results/'
# vmax = 1
# vmin=0

# EDFFiles=PatientsEDFFile(dir_mi_results)

# for file_idex in range(1):
#   # Name=EDFFiles[file_idex].split('.')
#   plt.rcParams['figure.figsize'] = [10, 10]
#   file_name = dir_mi_results + EDFFiles[file_idex]
#   print(EDFFiles[file_idex])
#   fig, ax = plt.subplots()
#   data = loadmat(file_name)
#   est_mi = data['estimated_MI']
#   plt.subplot(1,2,1)
#   plt.imshow((est_mi[0]), vmin=vmin, vmax=vmax,extent=(1,18,1,18))
#   plt.colorbar(shrink=0.35)
#   plt.title('No Seizure, 1NNperChan, File {}, mean {:.2f}'.format(file_idex, np.mean((est_mi[0]))))

#   plt.subplot(1,2,2)
#   plt.imshow((est_mi[1]), vmin=vmin, vmax=vmax, extent=(1,18,1,18))
#   # plt.colorbar()
#   plt.title('Seizure, 1NNperChan, File {}, mean {:.2f}'.format(file_idex, np.mean((est_mi[1]))))
#   plt.colorbar(shrink=0.35)

#   plt.show()
