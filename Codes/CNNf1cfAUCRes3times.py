# -*- coding: utf-8 -*-
"""CNNNSMILEModels.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yz_BpmDOOkww1Un3aK-NFBEfii4L7Bba
"""

# Commented out IPython magic to ensure Python compatibility.

import os
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"]="2"
from keras.models import Model
from keras.utils.generic_utils import get_custom_objects
from keras import optimizers, regularizers
import keras.backend as K
from keras import regularizers
from tensorflow.keras.layers import InputLayer
from keras.layers import Input
import time
import tensorflow as tf
import os
import scipy
import h5py
import glob, os
# import BaseLineModel
from scipy.io import loadmat
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
# from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten,Concatenate
from sklearn.metrics import confusion_matrix,classification_report
from sklearn.metrics import f1_score,plot_roc_curve
from sklearn.metrics import plot_precision_recall_curve,roc_curve,roc_auc_score,auc
from sklearn.metrics import precision_recall_fscore_support,precision_recall_curve
import matplotlib.pyplot as plt;
from keras.optimizers import Adam
from keras.layers.normalization import BatchNormalization
from keras.utils import np_utils
from keras.layers import Conv1D, MaxPooling1D, ZeroPadding1D, GlobalAveragePooling1D
from keras.layers.advanced_activations import LeakyReLU
from keras.preprocessing.image import ImageDataGenerator
from sklearn import preprocessing
from keras import regularizers
from numpy import mean
from numpy import std
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.layers import InputLayer
from keras.layers import Input
# from google.colab import drive
from sklearn.model_selection import LeaveOneOut
import gc
gc.collect()


def PatientsName():

  Name=['chb01','chb02','chb03','chb04','chb05','chb06','chb07','chb08','chb09','chb10',
      'chb11','chb12','chb13','chb14','chb15','chb16','chb17','chb18','chb19','chb20','chb21',
      'chb22','chb23','chb24']

  return Name
def PatientsEDFFile(dirname):

  os.chdir(dirname)
  a=[]
  X=[]
  Y=[]
  k=0
  for file in glob.glob("*.mat"):
      a.append(file)
      # print(a)
  return a

def ReadMatFiles(dirname,indx):


  EDF=[]
  EDFFiles=[]
  Name=[]
  EDF=PatientsEDFFile(dirname)
  Name=PatientsName()
  Xfile=[]
  Yfile=[]
  ind=[]

  MI2=[]
  X=[]
  Y=[]

  for j in list(indx):
    print(j)
    indices = [i for i, elem in enumerate(EDF) if Name[j] in elem]
    ind.append(indices)

  ind=np.concatenate(ind,axis=0)

  for k in range(len(ind)):
    # print(ind[k])
    matfile=loadmat(os.path.join(dirname,EDF[int(ind[k])]))
    x=matfile['X_4sec']
    y=matfile['Y_label_4sec']
    mi=matfile['estimated_MI']
    MI=np.zeros((mi.shape[0],153))
    for j in range(mi.shape[0]):

      mi2=mi[j,:,:]
      mi_mod=list(mi2[np.triu_indices(18,k=1)])
      MI[j,:]=mi_mod
    # MI=np.concatenate(MI,axis=0)
    # y=np.transpose(y)
    X.append(x)
    Y.append(y)
    MI2.append(list(MI))


  X=np.concatenate(X,axis=0)
  Y=np.concatenate(Y,axis=0)
  MI2=np.concatenate(MI2,axis=0)


  return X,Y,MI2

def ReadMatFilesDiff(dirname,indx):

  EDF=[]
  EDFFiles=[]
  Name=[]
  EDF=PatientsEDFFile(dirname)
  Name=PatientsName()
  Xfile=[]
  Yfile=[]
  ind=[]

  MI=[]
  X=[]
  Y=[]
  print(indx)
  for j in list(indx):
    print(j)
    indices = [i for i, elem in enumerate(EDF) if Name[j] in elem]

    ind.append(indices)

  ind=np.concatenate(ind,axis=0)

  for k in range(len(ind)):
    # print(ind[k])
    matfile=loadmat(os.path.join(dirname,EDF[int(ind[k])]))
    x=matfile['X_4sec']
    y=matfile['Y_label']
    mi=matfile['estimated_MI']



    # MI=np.concatenate(MI,axis=0)
    # y=np.transpose(y)
    X.append(x)
    Y.append(y)
    MI.append(mi)


  X=np.concatenate(X,axis=0)
  Y=np.concatenate(Y,axis=0)
  MI=np.concatenate(MI,axis=0)

  MI_diff=np.zeros((MI.shape[0]-1,MI.shape[1],MI.shape[2]))

  for j in range(MI.shape[0]-1):
    MI_diff[j,:,:]=MI[j+1,:,:]-MI[j,:,:]




  return X[1:,:,:,:],Y[1:,:],MI[1:,:,:],MI_diff

  def Calculation(y_test_thresh, predicted_class,pred_prob):


    precision, recall, fscore, _ = precision_recall_fscore_support(y_test_thresh, predicted_class, average='weighted')
    fpr, tpr, _ = roc_curve(y_test_thresh, pred_prob)

    precision, recall, _ = precision_recall_curve(y_test_thresh, pred_prob)
    PR=auc(recall, precision)
    ROC=roc_auc_score(y_test_thresh, pred_prob)

    return fpr,tpr,PR,ROC

dirname='/home/baharsalafian/6FoldData3times'


SaveResults='/home/baharsalafian/CNNSMILEGRURes3times'
modeldir='/home/baharsalafian/CNNSMILEGRURes3times'


fpr=[]
tpr=[]
PR=[]
ROC=[]
pred=[]
act=[]
fscore=[]

fold_no=1
batchsize=128
epoch=10
start_time = time.time()
FoldNum=6
model='CNNSMILE3times'
indx='test3times'
savenamef1='fscore_'+model+indx
cfname='cfmat_'+model+indx
fprname='fpr_'+model+indx
tprname='tpr_'+model+indx
prname='PR_'+model+indx
rocname='ROC_'+model+indx

threshold=0.5
kfold = KFold(n_splits=FoldNum, shuffle=False)
for th in [0.3,0.4,0.5,0.6,0.7,0.8,0.9]:

  fold_no=1
  for trainindx, testindx in kfold.split(range(24)):


    X_test,Y_test,mi_test= ReadMatFiles(dirname,testindx)
    ModelName1=model+ str(fold_no)+'.h5'
    model1=tf.keras.models.load_model(os.path.join(modeldir,ModelName1))
    ytest = (Y_test > threshold).astype(int)
    ypred1=model1.predict([X_test,mi_test])
    ypred = (ypred1 > th).astype(int)

      ###### Get the last element of the sequence of length 3
    ytest=ytest.reshape(ytest.shape[0],1)


    if th==0.9:

      fpr1, tpr1, _ = roc_curve(ytest, ypred1)
      precision, recall, _ = precision_recall_curve(ytest, ypred1)
      PR1=auc(recall, precision)
      ROC1=roc_auc_score(ytest,ypred1)
      fpr.append(fpr1)
      tpr.append(tpr1)
      PR.append(PR1)
      ROC.append(ROC1)

    precision, recall, f1, _ = precision_recall_fscore_support(ytest, ypred, average='weighted')
    fscore.append(f1)

    pred.append(list(ypred))
    act.append(list(ytest))
    fold_no=fold_no+1
  pred1=np.concatenate(pred,axis=0)
  act1=np.concatenate(act,axis=0)
  cnf_matrix = confusion_matrix(act1, pred1)

  np.save(os.path.join(SaveResults, savenamef1+str(th)),  fscore)
  np.save(os.path.join(SaveResults, cfname+str(th)),  cnf_matrix)


np.save(os.path.join(SaveResults, fprname),  fpr)
np.save(os.path.join(SaveResults, tprname),  tpr)
np.save(os.path.join(SaveResults, prname), PR)
np.save(os.path.join(SaveResults, rocname),  ROC)

print("--- %s seconds ---" % (time.time() - start_time))
